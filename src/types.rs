// Атрибут, который убирает предупреждения компилятора о неиспользуемом коде
#![allow(dead_code)]
#![allow(unused_variables)]
// Строчка ниже убирает все предупреждения, которые вызываются переполнением при преобразовании типов.
#![allow(overflowing_literals)]

// 5 Типы
/*
Rust предоставляет несколько механизмов изменения или определения примитивных и пользовательских типов:
    * Приведение между примитивными типами
    * Указание желаемого типа при помощи литералов
    * Использование вывода типов
    * Псевдонимы типов
*/

// 5.1 Приведение типов
/*
Rust не предусматривает неявного (принудительного) преобразования типов между примитивами.
Однако явное преобразование типов (casting) можно выполнить, используя ключевое слово `as`.
Правила, используемые для преобразования внутренних типов, такие же, как в языке C,
    за исключением тех случаев, когда преобразование типов в языке C вызывает неопределённое поведение.
Поведение всех приведений между встроенными типами чётко определено в Rust.
*/

fn casting() {
    let decimal = 65.4321_f32;
    // Ошибка! Нет неявного преобразования
    // let integer: u8 = decimal;

    // Явное преобразование
    let integer = decimal as u8;
    let character = integer as char;

    // Ошибка! Здесь ограничение в правилах конвертации.
    // Число с плавающей точкой не может быть напрямую конвертировано в символ.
    // let character = decimal as char;

    println!(
        "Преобразование: {} -> {} -> {}",
        decimal, integer, character
    );
    // >> Преобразование: 65.4321 -> 65 -> A

    // Когда преобразовывается любое значение в беззнаковый тип T std::T::MAX + 1 добавляется или вычитается до тех пор, пока значение не будет помещаться в новый тип.
    // 1000 поместится в u16

    println!("1000 as u16: {}", 1000 as u16);
    // >> 1000 as u16: 1000

    // 1000 - 256 - 256 - 256 = 232 Подробнее. Первые 8 младших битов (LSB) сохраняются, а старшие биты (MSB) будут усечены.
    println!("1000 as u8: {}", 1000 as u8);
    // >> 1000 as u8: 232

    // -1 + 256 = 255
    println!("-1 as u8: {}", -1i8 as u8);
    // >> -1 as u8: 255

    // Для положительных чисел результатом будет остаток от деления
    println!("1000 mod 256: {}", 1000 % 256);
    // >> 1000 mod 256: 232

    /*
       Когда значение преобразовывается в знаковый тип, побитовый результат будет таким же, как и
        первое преобразование к соответствующему типу без знака. Если старший бит этого значения равен 1, то это значение — отрицательное.
    */
    // За исключением тех случаев когда значение умещается в тип.
    println!("128 as i16: {}", 128 as i16);
    // >> 128 as i16: 128

    // 128 as u8 -> 128, дополнительный код которого в 8 битах:
    println!("128 as i8: {}", 128 as i8);
    // >> 128 as i8: -128

    // повторяем примеры
    // 1000 as u8 -> 232
    println!("1000 as u8: {}", 1000 as u8);
    // >> 1000 as u8: 232

    // и дополнительный код 232 — это -24
    println!("232 as i8: {}", 232 as i8);
    // >> 232 as i8: -24

    /*
        Начиная с Rust 1.45, ключевое слово `as` выполняет *насыщающее приведение* (saturating cast) при преобразовании в целое число с плавающей точкой.
        Если значение числа с плавающей точкой превышает верхнюю границу или меньше нижней границы, то возвращаемое значение будет равняться пересечённой границе.
    */
    println!("300.0 == {}", 300.0_f32 as u8);
    // >> 300.0 == 255
    println!("-100.0 as u8 == {}", -100.0_f32 as u8);
    // >> -100.0 as u8 == 0
    println!("nan as u8 == {}", f32::NAN as u8);
    // >> nan as u8 == 0

    /*
        Это поведение требует небольших затрат во время работы программы, и его можно избежать при помощи unsafe-методов,
        однако результат может пересечь границы, и мы получим ненадёжное значение.
    Используйте эти методы с умом:
    */
    unsafe {
        println!("300.0 == {}", 300.0_f32.to_int_unchecked::<u8>());
        // >> 300.0 == 44
        println!("-100.0 as u8 == {}", (-100.0_f32).to_int_unchecked::<u8>());
        // >> -100.0 as u8 == 156
        println!("nan as u8 == {}", f32::NAN.to_int_unchecked::<u8>())
        // >> nan as u8 == 0
    }
}

// 5.2 Литералы
/*
Числовые литералы могут быть обозначены добавлением типа в качестве суффикса.
Например, чтобы указать, что литерал 42 должен иметь тип i32, необходимо написать 42i32.

Без суффикса тип литерала будет зависеть от того, как он используется.
Если нет никаких ограничений, то компилятор будет использовать i32 для целочисленных литералов, а f64 — для литералов с плавающей точкой.
*/
fn literals() {
    // Литералы с суффиксами. Их тип известен при инициализации.
    let x = 1u8;
    let y = 2u32;
    let z = 3f32;

    // Литералы без суффиксов. Их тип будет зависеть от того, как их используют.

    let i = 1;
    let f = 1.0;

    println!("size of `x` in bytes: {}", std::mem::size_of_val(&x));
    // >> size of `x` in bytes: 1
    println!("size of `y` in bytes: {}", std::mem::size_of_val(&y));
    // >> size of `y` in bytes: 4
    println!("size of `z` in bytes: {}", std::mem::size_of_val(&z));
    // >> size of `z` in bytes: 4
    println!("size of `i` in bytes: {}", std::mem::size_of_val(&i));
    // >> size of `i` in bytes: 4
    println!("size of `f` in bytes: {}", std::mem::size_of_val(&f));
    // >> size of `f` in bytes: 8
}

// 5.3 Вывод типов
/*
Движок вывода типов весьма умён. Он делает куда больше, чем просто смотрит на тип r-value при инициализации.
Он также следит за тем, как используется значение после инициализации, чтобы определить его тип.
Вот расширенный пример вывода типов:
*/

fn type_inference() {
    // Благодаря выведению типов компилятор знает, что `elem` имеет тип `u8`.
    let elem = 5u8;

    // Создадим пустой вектор (расширяемый массив).
    let mut vec = Vec::new();
    // В данном месте компилятор не знает точный тип `vec`, он лишь знает, что это вектор каких-то значений (`Vec<_>`).

    // Добавляем `elem` в вектор.
    vec.push(elem);
    /*
    Ага! Теперь компилятор знает,
    что `vec` — это вектор, который хранит в себе тип `u8` (`Vec<u8>`)
    */
    println!("{:?}", vec);
    // >> [5]
}

// 5.4 Псевдонимы

/*
Оператор type используется, чтобы задать новое имя существующему типу.
Имя типа должно быть в стиле UpperCamelCase, иначе компилятор выдаст предупреждение.
Исключением являются примитивные типы: usize, f32 и другие.
*/

type NanoSecond = u64;
type Inch = u64;
// !Предупреждение: Type alias `u64_t` should have CamelCase name, e.g. `U64T`
#[allow(non_camel_case_types)]
// Используйте этот атрибут, чтобы не выводить предупреждение об именах не в стиле CamelCase
type u64_t = u64;

fn nicknames() {
    let nanoseconds: NanoSecond = 5 as u64_t;
    let inches: Inch = 2 as u64_t;

    println!(
        "{} nanoseconds + {} inches = {} unit?",
        nanoseconds,
        inches,
        nanoseconds + inches
    );
    // >> 5 nanoseconds + 2 inches = 7 unit?
}
/*
Основное применение псевдонимов — сокращение размера кода:
    например, тип IoResult<T> является псевдонимом типа Result<T, IoError>.
*/
pub fn run5() {
    casting();
    literals();
    type_inference();
    nicknames();
}
