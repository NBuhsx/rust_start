// 9. Функции
/*
Функции объявляются с помощью ключевого слова `fn`.
Их аргументы имеют явно заданный тип, как у переменных,
    и, если функция возвращает значение, возвращаемый тип должен быть указан после стрелки ->.

Последнее выражение в функции будет использовано как возвращаемое значение.
Так же можно использовать оператор return,
    чтобы вернуть значение из функции раньше, даже из цикла или оператора if.
*/

// Функция, которая возвращает булево значение
fn is_divisible_by(lhs: u32, rhs: u32) -> bool {
    // Особый случай, ранний возврат
    if rhs == 0 {
        return false;
    }
    // Это выражение, ключевое слово `return` здесь не требуется
    lhs % rhs == 0
}

// Функции которые "не" возвращают значение, на самом деле возвращают единичный тип `()`
fn fizzbuzz(n: u32) -> () {
    if is_divisible_by(n, 15) {
        println!("fizzbuz");
    } else if is_divisible_by(n, 3) {
        println!("fizz");
    } else if is_divisible_by(n, 5) {
        println!("buzz");
    } else {
        println!("{}", n)
    }
}
// Если функция возвращает `()`, тип возвращаемого значения можно не указывать в сигнатуре
fn fizzbuzz_to(n: u32) {
    for n in 1..=n {
        fizzbuzz(n);
    }
}

fn func() {
    fizzbuzz_to(100);
}

// 9.1 Методы
/*
Некоторые функции связаны с определённым типом.
Они бывают двух видов: связанные функции и методы.
Связанные функции — это функции, которые обычно определены для типа в целом.
Методы — это связанные функции, которые вызываются для конкретного экземпляра типа.
*/

struct Point {
    x: f64,
    y: f64,
}

// Блок реализации, все функции и методы, связанные с типом `Point` размещаются здесь
impl Point {
    /*
    Это "связанная функция", так как эта функция связана с конкретным типом, в данном случае, Point.
    Связанные функции не обязательно вызывать с каким-то экземпляром класса.
    Чаще всего такие функции используются как конструкторы.
    */
    fn origin() -> Point {
        Point { x: 0.0, y: 0.0 }
    }
    // Ещё одны связанная функция, принимающая два аргумента:
    fn new(x: f64, y: f64) -> Point {
        Point { x, y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    /*
    Это метод
    `&self` - это синтаксический сахар для замены `self: &Self`, где `Self` - это тип вызывающего объекта
    В данном случае `Self` = `Rectangle`
    */
    fn area(&self) -> f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;
        // `abs` - это метод, возвращающий переменную типа `f64`, равную абсолютному значению вызывающего объекта
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&self) -> f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 + y2).abs())
    }

    /*
    Этот метод требует, чтобы вызывающий объект был изменяемым
    `&mut self` преобразуется в  `self: &mut Self`
    */
    fn translate(&mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` владеет ресурсами: двумя целыми числами, память для которых выделена в куче
struct Pair(Box<i32>, Box<i32>);

impl Pair {
    /*
    Этот метод "потребляет" ресурсы вызывающего объекта `self` преобразуется в `self: Self`
    */
    fn destroy(self) {
        let Pair(first, second) = self;
        println!("Удаляем Pair({}, {})", first, second);
    }
}

fn method() {
    let rectangle = Rectangle {
        // Связанные функции вызываются с помощью двойных двоеточий
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    /*
    Методы вызываются с помощью оператора "точка"
    Обратите внимание, что первый аргумент `&self` передаётся неявно, т.е.
        `rectangle.perimeter()` === `Rectangle::perimeter(&rectangle)`
    */
    println!("Периметр прямоугольника: {}", rectangle.perimeter());
    // >> Периметр прямоугольника: 14
    println!("Площадь прямоугольника: {}", rectangle.area());
    // >> Площадь прямоугольника: 12

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Ошибка! `rectangle` неизменяемый, но в методе требуется изменяемый объект
    // rectangle.translate(1.0, 1.0);

    // Порядок! Изменяемые объекты могут вызывать изменяемые методы
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();
    // Ошибка! Предыдущий вызов `destroy` "употребил" переменную `pair`
    // pair.destroy();
}

// 9.2 Замыкание
/*
Замыкания в Rust, так же называемые лямбда, это функции, которые замыкают своё окружение.
Для примера, замыкание, которое захватывает значение переменной x:
    `|val| val + x`
Синтаксис и возможности замыканий делают их очень удобными для использования "на лету".
Использование замыканий похоже на использование функций.
Однако, тип входных и возвращаемых значений может быть выведен, а название аргумента должно быть указано.

Другие характеристики замыканий включают в себя:
    использование || вместо () для аргументов.
    опциональное ограничения тела функции ({}) для одного выражения (в противном случае обязательно).
    возможность захвата переменных за пределами окружения

*/

fn circuit() {
    // Инкремент с помощью замыкания и функции.
    fn funtion(i: i32) -> i32 {
        i + 1
    }

    /*
    Замыкания анонимны. Тут мы связываем их с ссылками
    Аннотация идентичны аннотации типов функции, но является опциональной
        как и оборачивания тела в `{}`.
    Эти безымянные функции назначены соответствующе названным переменным.
    */
    let closure_annotated = |i: i32| -> i32 { i + 1 };
    let closure_inferred = |i| i + 1;

    let i = 1;

    println!("Функция: {}", funtion(i));
    // >> Функция: 2
    println!("Замыкание с указанием типа: {}", closure_annotated(i));
    // >> Замыкание с указанием типа: 2
    println!("Замыкание с выводом типа: {}", closure_inferred(i));
    // >> Замыкание с выводом типа: 2

    let one = || 1;
    println!("Замыкание, возращает один: {}", one());
    // >> Замыкание, возращает один: 1
}

// 9.2.1 Захват
/*
Замыкания довольно гибкие и делают всё, что требуется, для работы с ними без дополнительных указаний.
Это позволяет захватывать переменные гибко, перемещая их или заимствуя, в зависимости от ситуации.
Замыкания могут захватывать переменные:
    по ссылке: &T
    по изменяемой ссылке: &mut T
    по значению: T
Преимущественно, они захватывают переменные по ссылке, и используют другие способы только там, где это необходимо.
*/

fn circuit_capture() {
    use std::mem;

    let color = "green";
    /*
    Замыкание для вывода `color`, которое немедленно заимствует (`&`)
        `color` и сохраняет замыкание в переменной `print`. `color` будет оставаться
    заимствованным до тех пор, пока `print` не будет использован в последний раз.
    `println!` принимает аргументы только по неизменяемым ссылкам,
        поэтому он не накладываетдополнительных ограничений.
    */

    let print = || println!("color: {}", color);
    // Вызывает замыкание, использующее заимствование.
    print();
    // >> color: green

    // `color` может быть неизменяемо заимствован, так как замыкание держит то только неизменяемую ссылку на `color`.
    let _reborrow = &color;
    print();
    // >> color: green

    // Перемещение или перезанятие возможно после последнего использования `print`
    let _color_moved = color;

    let mut count = 0;
    /*
    Замыкание для увеличения `count` может принимать как `&mut count`, так и `count`,
        но использование `&mut count` накладывает меньше ограничений,
        так что замыкание выбирает первый способ, т.е. немедленно заимствует `count`.
        `inc` должен быть `mut`, поскольку внутри него хранится `&mut`.
    Таким образом, вызов замыкания изменяет его, что недопустимо без `mut`.
    */
    let mut inc = || {
        count += 1;
        println!("count: {}", count)
    };
    for _ in 1..5 {
        /*
        Вызываем замыкание, использующее изменяемое заимствование.
        Замыкание продолжает изменяемо заимствовать `count`, так как оно используется дальше.
        Попытка перезанять приведёт к ошибке.
        // let _reborrow = &count;
        // ^ TODO: попробуйте раскомментировать эту строку.
        */
        inc();
        // Попытка перезанять приведёт к ошибке.
        // let _reborrow = &count;
    }

    /*
    Замыкание больше не заимствует `&mut count`.
    Так что теперь при перезаимствовании ошибок не будет.
    */
    let _count_reborrweb = &mut count;

    // Некопируемый тип.
    let movable = Box::new(3);

    /*
    `mem::drop` требует `T`, так что захват производится по значению.
    Копируемый тип будет скопирован в замыкание, оставив оригинальное значение без изменения.
    Некопируемый тип должен быть перемещён, так что movable` немедленно перемещается в замыкание.
    */
    let consume = || {
        println!("moveble: {:?}", movable);
        mem::drop(movable);
    };
    // `consume` поглощает переменную, так что оно может быть вызвано только один раз.
    consume();
    // Ошибка так как переменной `movable` уже не сущществует
    // consume();
    // println!("{:?}", movable);

    /*
    Использование move перед вертикальными линиями позволяет получить владение над захваченными переменными:
    */
    let haystack = vec![1, 2, 3];

    let contains = move |needle| haystack.contains(needle);
    println!("{}", contains(&1));
    // >> true
    println!("{}", contains(&7));
    // >> false

    // !Ошибка `move` передало владение в функцию. `haystack` больше не существует
    // println!("Количество элементов {} в векторе", haystack.len());
    // >> Количество элементов 3 в векторе
}

pub fn run9() {
    func();
    method();
    circuit();
    circuit_capture();
}
