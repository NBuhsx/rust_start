// Атрибут, который убирает предупреждения компилятора о неиспользуемом коде
#![allow(dead_code)]
#![allow(unused_variables)]
// 1 Привет, мир!
// Эта строка — комментарий, она будет проигнорирована компилятором
fn hello_world() {
    // Следующий код будет исполнен в момент, когда будет запущен исполняемый файл
    // println! - это макрос, который отображает текст в консоли.
    println!("Привет, мир!");
    // >> Привет, мир!
    println!("Я программирую на языке Rust!")
    // >> Я программирую на языке Rust!
}

// 1.1 Комментарии
/*
Обычные комментарии, которые игнорируются компилятором:
    // - Однострочный комментарий. Который завершается в конце строки.
    /* - Блочный комментарий, который продолжается до завершающего символа. */
Doc комментарии, которые будут сгенерированы в HTML
    /// - Генерация документации для функции.
    //! - Генерация документации для модуля.
*/

fn comments() {
    // Это пример комментария к строке. В начале строки две косые чер
    // И ничего написанного внутри них не будет прочитано компилятором.
    // println!("Hello, world!");

    /*
     * Это еще один тип комментария — блочный комментарий.
     * Линейные комментарии — рекомендуемый стиль комментариев.
     * Но комментарии к блокам чрезвычайно полезны для временного отключения
     * кусков кода. /* Блочные комментарии могут быть /* вложенными, */ */
     * поэтому требуется всего несколько нажатий клавиш, чтобы все закомментировать
     * в этой функции main(). /*/*/* Попробуй сам! */*/*/
     */

    // Вы можете легче манипулировать выражениями с помощью комментариев к блокам.
    // чем с комментариями к строке.

    let x = 5 + /* 90 +*/ 5;
    println!("Is 'x' 10 or 100? x = {}", x);
    // >> Is 'x' 10 or 100? x = 10
    // Eсли раскоментировать /*90 + */
    // >> Is 'x' 10 or 100? x = 100
}

// 1.2 Форматированый вывод
// Вывод обрабатывается несколькими макросами, которые определены в std::fmt. Вот некоторые из них:

/*
    format! - Записывает форматированный текст в String.
    print!: - Pаботает аналогично с format!, но текст выводится в консоль (io::stdout).
    println! - Aналогично print!, но в конце добавляется переход на новую строку.
    eprint! - Aналогично format!, но текст выводится в стандартный поток ошибок (io::stderr).
    eprintln! - Aналогично eprint!, но в конце добавляется переход на новую строку
*/

fn formating() {
    // `{}` автоматически будет заменено на
    // аргументы. Они будут преобразованы в строку.

    println!("{} дней", 31);
    // >> 31 дней

    // Без суффиксов, 31 является i32. Можно изменить тип 31, используя суффикс.
    println!("{} дней", 31i8);
    // >> 31 дней

    // Существует множество способов работы с форматированным выводом. Можно указать
    // позицию для каждого аргумента.
    println!("{0}, это {1}. {1}, это {0}", "Aлиса", "Боб");
    // Aлиса, это Боб. Боб, это Aлиса

    // Так же можно именовать аргументы.
    println!(
        "{subject} {verb} {object}",
        object = "леннивую собаку",
        subject = "быстрая коричневая лиса",
        verb = "прыгает через"
    );
    // >> быстрая коричневая лиса прыгает через леннивую собаку

    println!(
        "{} из {:b} людей знают, что такое двоичный код, a остальные нет.",
        1, 2
    );
    // >> 1 из 10 людей знают, что такое двоичный код, a остальные нет.

    // Можно выравнивать текст, сдвигая его на указанную ширину.
    println!("{number:>width$}", number = 1, width = 6);
    // >>      1

    // Можно добавить к цифрам пару нулей. Данный макрос выведет "000001".
    println!("{number:0>width$}", number = 1, width = 6);
    // >> 000001

    // Округление дробного числа
    println!("{:.3}", 3.141592f32);
    // >> 3.142
}

// !!! СТАНДАРТНАЯ БИБЛИОТЕКА ФОРМАТИРОВАНИЯ https://doc.rust-lang.org/std/fmt/

/*
std::fmt содержит в себе много типажей, которые управляют отображением текста.
Базовая форма двух самых важных рассмотрена ниже:
    fmt::Debug - Использует маркер {:?}. Форматирует текст для отладочных целей.
    fmt::Display - Использует маркер {}. Форматирует текст в более элегантном,удобном для пользователя стиле.

В данном примере используется fmt::Display, потому что стандартная библиотека предоставляет реализацию для данного типа.
Для отображения собственных типов потребуется больше дополнительных шагов.
*/

// 1.2.1 Формат DEBUG
// Эта структура не может быть напечатана с помощью `fmt::Display`или с помощью `fmt::Debug
// struct UnPrintable(i32);

// Атрибут `derive` автоматически реализует необходимые методы,
// чтобы была возможность напечатать структуру `struct` с помощью `fmt::Debug`.
#[derive(Debug)]
struct DebugPrintable(i32);

#[derive(Debug)]
struct Deep(DebugPrintable);

#[derive(Debug)]
struct Person<'a> {
    name: &'a str,
    age: u8,
}
fn formating_debug() {
    // Вывод с помощью `{:?}` DEBUG аналогичен `{}`.
    println!("{:?} месяцев в году", 12i8);
    // >> 12 месяцев в году

    println!(
        "{1:?} {0:?} - это имя {actor:?}.",
        "Слейтер",
        "Кристиан",
        actor = "актёра"
    );
    // >> Кристиан" "Слейтер" - это имя "актёра".

    println!("Теперь {:?} будет выведена на экран!", DebugPrintable(8));
    // >> Теперь DebugPrintable(8) будет выведена на экран!

    println!("A теперь напечатаем {:?}", Deep(DebugPrintable(7)));
    // >> A теперь напечатаем Deep(DebugPrintable(7))

    /*
        Так что fmt::Debug определённо позволяет распечатать объект, но жертвует некоторым изяществом.
        Rust также обеспечивает "красивую печать" с помощью {:#?}.
    */

    println!(
        "{:#?}",
        Person {
            name: "Peter",
            age: 27
        }
    );
    /*
    >> Person {
        name: "Peter",
        age: 27,
     */
}

//  1.2.2 Формат Disply
/*
fmt::Debug выглядит не очень компактно и красиво, поэтому полезно настраивать внешний вид информации, которая будет напечатана.
Это можно сделать реализовав типаж fmt::Display вручную, который использует маркер {} для печати.
Его реализация выглядит следующим образом:
*/

use core::str;
// Импортируем (с помощью `use`) модуль `fmt`, чтобы мы могли его использовать.
use std::fmt;

struct Structure(i32);

// Чтобы была возможность использовать маркер `{}`
// `типаж (trait) fmt::Display` должен быть реализован вручную
impl fmt::Display for Structure {
    // Этот типаж требует реализацию метода 'fmt' c данной сигнатурой:
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // Записываем первый элемент в предоставленный выходной поток: `f`.
        // Возвращаем `fmt::Result`, который показывает выполнилась операция
        write!(f, "{}", self.0)
    }
}

#[derive(Debug)]
struct MinMax(i64, i64);

impl fmt::Display for MinMax {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Используем `self.номер`, чтобы получить доступ к каждому полю структуры.
        write!(f, "({}, {})", self.0, self.1)
    }
}

// Объявим структуру с именованными полями, для сравнения
#[derive(Debug)]
struct Point2D {
    x: f64,
    y: f64,
}

#[derive(Debug)]
struct Complex {
    real: f32,
    imag: f32,
}
impl fmt::Display for Complex {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} + {}i", self.real, self.imag)
    }
}

impl fmt::Display for Point2D {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Обращаться к полям структуры Point2D будет по имени
        write!(f, "x: {}, y: {}", self.x, self.y)
    }
}

fn formating_display() {
    let minmax = MinMax(0, 14);
    println!("Сравниваем форматирование:");
    // >> Сравниваем форматирование:
    println!("Display: {}", minmax);
    // >> Display: (0, 14
    println!("Debug: {:?}", minmax);
    // >> Debug: MinMax(0, 14)

    let big_range = MinMax(-300, 300);
    let small_range = MinMax(-3, 3);

    println!(
        "Большой диапозон - {big} и маленький диапозон {small}",
        small = small_range,
        big = big_range
    );
    // >> Большой диапозон - (-300, 300) и маленький диапозон (-3, 3)

    let point = Point2D { x: 3.3, y: 7.2 };
    println!("Сравниваем форматирование:");
    // >> Сравниваем форматирование:
    println!("Display: {}", point);
    // >> Display: x: 3.3, y: 7.2
    println!("Debug: {:?}", point);
    // >> Debug: Point2D { x: 3.3, y: 7.2 }

    // Задание
    let complex = Complex {
        real: 3.3,
        imag: 7.2,
    };
    println!("Сравниваем форматирование:");
    // >> Сравниваем форматирование:
    println!("Display: {}", complex);
    // >> Display: 3.3 + 7.2i
    println!("Debug: {:?}", complex);
    // >> Complex { real: 3.3, imag: 7.2 }
}

// 1.2.2.1 Пример форматирования Списка

/*
Реализовать fmt::Display для структуры, в которой каждый элемент должен обрабатываться последовательно, не так-то просто.
Проблема в том, что write! каждый раз возвращает fmt::Result.
Для правильного обращения с этим необходимо обрабатывать все результаты. Для этой цели Rust предоставляет оператор ?.
*/

// Было определено выше
// use std::fmt;
// // Определяем структуру с именем `List`, которая хранит в себе `Vec`
struct List(Vec<i32>);

impl fmt::Display for List {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        // Получаем значение с помощью индекса кортежа и создаём ссылку на `vec`.
        let vec = &self.0;
        // Используйте ?, чтобы узнать, вернется ли ошибка. Если будет ошибка — верни её. Если нет, то продолжи.
        write!(f, "[")?;
        // Пройдёмся по каждому `v` в `vec`. Номер итерации хранится в `count`.
        for (count, v) in vec.iter().enumerate() {
            // Для каждого элемента, кроме первого, добавим запятую до вызова `write!`.
            // Используем оператор `?` или `try!`, чтобы вернуться при наличии ошибок.
            if count != 0 {
                write!(f, ", ")?;
            }
            // write!(f, "{}", v)?;
            // Задание. Дополнить вывод индекса
            write!(f, "{}: {}", v, count)?;
        }
        // Закроем открытую скобку и вернём значение `fmt::Result`
        write!(f, "]")
    }
}

fn formating_list() {
    let v = List(vec![1, 2, 3]);
    println!("{}", v);
    // >> [1, 2, 3]
    // Задание. Дополнить вывод индекса
    // >> [1: 0, 2: 1, 3: 2]

    println!("{}", List(vec![10, 100, 1000, 5433, 0, 10]));
    // >> [10, 100, 1000, 5433, 0, 10]
    // Задание. Дополнить вывод индекса
    // >> [10: 0, 100: 1, 1000: 2, 5433: 3, 0: 4, 10: 5]
}

// 1.2.3 Форматирование
/*
Мы видели, что форматирование задаётся макросом форматирования:

    format!("{}", foo) -> "3735928559"
    format!("0x{:X}", foo) ->"0xDEADBEEF"
    format!("0o{:o}", foo) -> "0o33653337357"

Одна и та же переменная (foo) может быть отображена по разному в зависимости от используемого типа аргумента: X, o или неопределённый.
Функционал форматирования реализован благодаря типажу, и для каждого типа аргумента существует свой.
Наиболее распространённый типаж для форматирования — Display, который работает без аргументов: например {}.
*/

struct City {
    name: &'static str,
    lat: f32,
    lon: f32,
}

impl fmt::Display for City {
    // `f` — это буфер, данный метод должен записать в него форматированную строку
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let lan_c = if self.lat >= 0.0 { 'N' } else { 'S' };
        let lon_c = if self.lon >= 0.0 { 'E' } else { 'W' };

        write!(
            f,
            "{}: {:.3}°{} {:.3}°{}",
            self.name,
            self.lat.abs(),
            lan_c,
            self.lon.abs(),
            lon_c
        )
    }
}

#[derive(Debug)]
struct Color {
    red: u8,
    green: u8,
    blue: u8,
}

impl fmt::Display for Color {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "RGB({}, {}, {}) 0x{:02x}{:02x}{:02x}",
            self.red, self.green, self.blue, self.red, self.green, self.blue,
        )
    }
}

fn formating_formating() {
    for city in [
        City {
            name: "Дублин",
            lat: 59.347778,
            lon: -6.259722,
        },
        City {
            name: "Осло",
            lat: 59.95,
            lon: 10.75,
        },
        City {
            name: "Ванкувер",
            lat: 49.25,
            lon: -123.1,
        },
    ]
    .iter()
    {
        println!("{}", *city);
        /*
        >> Дублин: 59.348°N 6.260°W
        >> Осло: 59.950°N 10.750°E
        >> Ванкувер: 49.250°N 123.100°W
        */
    }
    for color in [
        Color {
            red: 128,
            green: 255,
            blue: 90,
        },
        Color {
            red: 0,
            green: 3,
            blue: 254,
        },
        Color {
            red: 0,
            green: 0,
            blue: 0,
        },
    ]
    .iter()
    {
        println!("{:?}", *color);
        /*
        >> Color { red: 128, green: 255, blue: 90 }
        >> Color { red: 0, green: 3, blue: 254 }
        >> Color { red: 0, green: 0, blue: 0 }
        */
        println!("{}", *color);
        /*
        >> RGB(128, 255, 90) 0x80ff5a
        >> RGB(0, 3, 254) 0x0003fe
        >> RGB(0, 0, 0) 0x000000
        */
    }
}

// Вызов
pub fn run1() {
    hello_world();
    comments();
    formating();
    formating_debug();
    formating_display();
    formating_list();
    formating_formating();
}
