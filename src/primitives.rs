// Атрибут, который убирает предупреждения компилятора о неиспользуемом коде
#![allow(dead_code)]
#![allow(unused_variables)]
// 2 Примитивы

/*
### Скалярные типы
#### Целые числа
Если размер не указан, то считается, что числовое значение имеет тип i32
    isize - хранит целое число со знаком, размерность которого зависит от архитектуры компьютера - 64 бита на 64-битной архитектуре, и 32 бита на 32-битной арх
        i8 - хранит целое число со знаком и занимает в памяти 8 бит (диапазон значений от -128 до 127)
        i16 - 128 - хранит целое число со знаком и занимает в памяти 16 бит
    usize - хранит положительное целое число, размерность которого зависит от архитектуры компьютера - 64 бита на 64-битной архитектуре, и 32 бита на 32-битной архитектуре
        u8 - хранит положительное целое число и занимает в памяти 8 бит (диапазон значений от 0 до 255)
        u16-128 - хранит положительное целое число и занимает в памяти 16 бит

#### Дробные
Если размер не указан, то считается что числовое значение имеет тип 64
    f32 - хранит число с плавающей точкой, которое занимает в памяти 32 бита
    f64 - хранит число с плавающей точкой, которое занимает в памяти 64 бита

#### Двоичный, Восьмеричный, Шестнадцатеричный
    Двоичный формат - перед числом ставится 0b: let a = 0b0101;
    Восьмеричный формат - перед числом ставится 0o: let a = 0o11;
    Шестнадцатеричный формат - перед числом ставится 0x: 0xA1;

#### Логический
    bool: let g:bool = True

#### Символьный
    char - Символьный тип или char может хранить отдельные символы Unicode.
    Каждый символ заключается в одинарные кавычки. В памяти он занимает 4 байта.
    let a: char = 'a';

#### Eдиничный тип (), значение которого так же ()


### Составные типы
Строки
    Строка хранит набор символов в кодировке UTF-8, который заключается в двойные кавычки.

Mассивы, например [1, 2, 3]
Kортежи, например (1, true)
*/

fn primitives() {
    let logical = true;
    // Обычная аннотация
    let a_float: f64 = 1.0;

    // Суффиксная аннотация
    let an_integer = 5i32;

    // Этим переменным будет присвоен тип по умолчанию.
    let default_float = 3.0;
    let default_integer = 6;

    // Тип также может быть выведен из контекста.
    let mut inferred_type = 12;
    // Тип i64 выводится из другой строки
    inferred_type = 4294967296i64;

    // Значение изменяемой переменной может быть изменено.
    let mut mutable = 12;
    mutable = 21;

    // Ошибка! Тип переменной изменить нельзя.
    // mutable = true;

    // Переменные могут быть переопределены с помощью затенения.
    let mutable = true;

    println!(
        "Дробные: logical={}, default_float{}",
        a_float, default_float
    );
    // >> Дробные: logical=1, default_float3
    println!(
        "Целые: an_integer={}, default_integer={}, inferred_type={}",
        an_integer, default_integer, inferred_type
    );
    // >> Целые: an_integer=5, default_integer=6, inferred_type=4294967296
    println!("Логические: logical={}, mutable={}", logical, mutable);
    // >> Логические: logical=true, mutable=true
}

// Литералы и операторы

/*
Целочисленные значения так же могут быть выражены с помощью:
    шестнадцатеричного (0x),
    восьмеричного (0o),
    или двоичного (0b)
Для улучшения читаемости числовых литералов можно использовать подчёркивания,
    например 1_000 тоже самое, что и 1000,
    и 0.000_001 равно 0.000001.

Нам необходимо указать компилятору какой тип для литерала мы используем.
Сейчас мы используем суффикс u32, чтобы указать, что литерал - беззнаковое целое число 32-х бит и суффикс i32 - знаковое целое 32-х битное число.
 */

fn litetal_and_operator() {
    // Aрифметические операции
    println!("1 + 2 = {}", 1i32 + 2);
    // >> 1 + 2 = 3
    println!("1 - 2 = {}", 1i32 - 2);
    // >> 1 - 2 = -1
    println!("1 * 2 = {}", 1i32 * 2);
    // >> 1 * 2 = 2
    // Операции деления будет работь для целых чисел до целых чисел
    println!("4 / 2 = {}", 4i32 / 2);
    // >> 4 / 2 = 2
    // Операции деления будет работь для дробных чисел с дробью
    println!("4.2 / 2.1 = {}", 4f32 / 2.1f32);
    // >> 4.2 / 2.1 = 1.904762
    println!("10 % 3 = {}", 10i8 % 3);
    // >> 10 % 3 = 1

    // Арифметические операции + присваивание
    let mut n = 10;
    n += 1;
    println!("n += 1 = {}", n);
    // >> n += 1 = 11
    n -= 1;
    println!("n -= 1 = {}", n);
    // >> n -= 1 = 10
    n *= 2;
    println!("n *= 2 = {}", n);
    // >> n -= 1 = 10
    n /= 2;
    println!("n /= 2 = {}", n);
    // >> n /= 2 = 10
    n %= 6;
    println!("n %=6 = {}", n);
    // >> n %=6 = 4

    /*
    Логические операции:
        ! - НЕТ (not)
        && - И
        || - ИЛИ
    */
    println!("true И fasle будет {}", true && false);
    // >> true И fasle будет false
    println!("true ИЛИ false будет {}", true || false);
    // >> true ИЛИ false будет true
    println!("НЕ true будет {}", !true);
    // >> НЕ true будет false

    /*
    Побитовые операции
    & - поразрядная конъюнкция (операция И или поразрядное умножение).
    | - поразрядная дизъюнкция (операция ИЛИ или поразрядное сложение).
    ^ - поразрядное исключающее ИЛИ. Возвращает 1, если только один из соответствующих разрядов обоих чисел равен 1
    << - Левый сдвиг - это бинарный оператор, который принимает два числа, сдвигает влево биты первого операнда, а второй операнд определяет количество позиций для сдвига
    >> - Правый сдвиг - это бинарный оператор, который принимает два числа, сдвигает вправо биты первого операнда, а второй операнд определяет количество позиций для сдвига
    */
    println!("0011 и 0101 будет {:04b}", 0b0011u32 & 0b0101);
    // >> 0011 и 0101 будет 0001
    println!("0011 ИЛИ 0101 будет {:04b}", 0b0011u32 | 0b0101);
    // >> 0011 ИЛИ 0101 будет 0111
    println!("0011 исключающее ИЛИ 0101 будет {:04b}", 0b0011u32 ^ 0b0101);
    // >> 0011 исключающее ИЛИ 0101 будет 0110
    println!("1 << 5 будет {}", 1u32 << 5);
    // >> 1 << 5 будет 32
    println!("0x80 >> 2 будет 0x{:x}", 0x80u32 >> 2);
    // >> 0x80 >> 2 будет 0x20

    // Использование подчёркивания для улучшения читаемости!
    println!("Один миллион записан как {}", 1_000_000u32);
    // >>
}

// 2.2 Кортежи
/*
Кортежи - коллекция, которая хранит в себе переменные разных типов.
Кортежи создаются с помощью круглых скобок (),
и каждый кортеж является переменной с сигнатурой типов (T1, T2, ...), где T1, T2 тип члена кортежа.
Функции могут использовать кортежи для возвращения нескольких значений, так кортежи могут хранить любое количество значений.
*/

use std::fmt;

fn reverse(pair: (i32, bool)) -> (bool, i32) {
    let (integer, boolean) = pair;
    (boolean, integer)
}

#[derive(Debug)]
struct Matrix(f32, f32, f32, f32);

impl fmt::Display for Matrix {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "({}, {})\n({}, {})", self.0, self.1, self.2, self.3)
    }
}

impl Matrix {
    fn transpose(&self) -> Matrix {
        Matrix(self.0, self.2, self.1, self.3)
    }
}

fn tuple() {
    let long_tuple = (
        1u8, 2u16, 2u32, 4u64, -1i8, -2i16, -3i32, -4i64, 0.1f32, 0.2f64, 'a', true,
    );
    // К значениям переменных внутри кортежа можно обратиться по индексу
    println!("Первое значение длинного кортежа: {}", long_tuple.0);
    // >> Первое значение длинного кортежа: 1
    println!("Второе значение длинного кортежа: {}", long_tuple.1);
    // >> Второе значение длинного кортежа: 2

    // Кортежи могут содержать в себе кортежи
    let tuple_of_tuple = ((1u8, 2u16, 2u32), (4u64, -1i8), -2i16);
    // Но длинные Кортежи не могут быть напечатаны
    println!("Кортеж из кортежей {:?}", tuple_of_tuple);
    // >> Кортеж из кортежей ((1, 2, 2), (4, -1), -2)

    let pair = (1, true);
    println!("Pair хранит в себе {:?}", pair);
    // >> Pair хранит в себе (1, true)

    println!("Перевёрнутая pair будет {:?}", reverse(pair));
    // >> Перевёрнутая pair будет (true, 1)

    // Для создания кортежа, содержащего один элемент, необходимо написать элемент и
    // поставить запятую внутри круглых скобок.
    println!("Кортеж из одного элемента: {:?}", (5u32,));
    // >> Кортеж из одного элемента: (5,)
    println!("Просто целочисленное значение: {:?}", (5u32));
    // >> Просто целочисленное значение: 5

    // Кортежи можно разобрать на части (деструктурировать) для создания связи
    let tuple = (1, "привет", 4.5, true);

    let (a, b, c, d) = tuple;
    println!("{}, {}, {}, {}", a, b, c, d);
    // >> 1, "привет", 4.5, true

    // Определение кортежной структуры
    let matrix = Matrix(1.1, 1.2, 2.1, 2.2);
    println!("{:?}", matrix);
    // >> Matrix(1.1, 1.2, 2.1, 2.2
    println!("Matrix:\n{}", matrix);
    /*
    >> Matrix:
    (1.1, 1.2)
    (2.1, 2.2)
    */
    println!("Transpose:\n{}", matrix.transpose());
    /*
    >> Transpose:
    (1.1, 2.1)
    (1.2, 2.2)
    */
}

// 2.3 Массивы и срезы
/*
Массив — это коллекция объектов одинакового типа T, расположенных в памяти непосредственно друг за другом.
Массивы создаются с помощью квадратных скобок [],
а их размер должен быть известен во время компиляции и является частью сигнатуры типа [T; size].

Срезы похожи на массивы, но их размер неизвестен в момент компиляции программы.
Срезы представляют собой объекты, состоящие из указателя на данные и размер среза.
Размер среза равен размеру usize и зависит от архитектуры процессора: например, для x86-64 он равен 64 битам.
Срезы могут быть использованы для заимствования части массива и будут иметь сигнатуру типа &[T].
*/

use ::std::mem;

fn analyze_slice(slice: &[i32]) {
    println!("Первый элемент среза: {}", slice[0]);
    println!("В срезе {} элементов", slice.len());
}

fn arr_and_slice() {
    // Массив фиксированного размера (указывать сигнатуру типа необязательно)
    let xs: [i32; 5] = [1, 2, 3, 4, 5];
    let ys = [0; 500];

    // Индекс начинается с 0
    println!("Первый элемент массива: {}", xs[0]);
    // >> Первый элемент массива: 1
    println!("Второй элеменгт массива: {}", xs[1]);
    // Второй элеменгт массива: 2

    // `len` возвращает длину массива
    println!("Размер массива: {}", xs.len());
    // >> Размер массива: 5

    println!("Массив занимает {} байт", mem::size_of_val(&xs));
    // >> Массив занимает 20 байт
    println!("Массив занимает {} байт", mem::size_of_val(&ys));
    // >> Массив занимает 2000 байт

    // Заимствуем весь массив как срез
    // Массивы могут быть автоматически заимствованы как срез
    analyze_slice(&xs);
    /*
    >> Первый элемент среза: 1
    >> В срезе 5 элементов
    */

    /*
    Срезы могут указывать на часть массива
    Они имеют форму [starting_index..ending_index]
        starting_index — это первая позиция в срезе
        ending_index — на 1 больше, чем последняя позиция в срезе
    */
    // Заимствуем часть массива как срез
    analyze_slice(&ys[1..4]);
    /*
    >> Первый элемент среза: 0
    >> В срезе 3 элементов
    */
}

pub fn run2() {
    primitives();
    litetal_and_operator();
    tuple();
    arr_and_slice();
}
