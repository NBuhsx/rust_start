// 8 Управление потоком
// Неотъемлемой частью любого языка программирования являются управляющие конструкции: if / else , for и другие.

// 8.1 if/else

/*
Ветвление с помощью if-else похоже на аналоги в других языка программирования.
В отличие от многих из них, логическое условие не должно быть заключено в круглые скобки,
    а после каждого условия должен следовать блок.
Условные операторы if-else являются выражениями, и все ветки должны возвращать значения одного и того же типа.
*/

fn if_else() {
    let n = 5;
    if n < 0 {
        println!("{} - Отрицательное число", n);
    } else if n > 0 {
        println!("{} - Положительное число", n);
    } else {
        println!("{} - нуль", n);
    }

    let big_n = if n < 10 && n > -10 {
        println!(", малое по модулю число, умножим его в десять раз");
        // Это выражение вернёт `i32`.
        10 * n
    } else {
        println!(", большое по модулю число, уменьшим его в вдвое");
        // И это выражение вернёт `i32`.
        n / 2
    };
    // Не забудьте добавить тут точку с запятой! Все операторы `let` требуют её..

    println!("{} -> {:?}", n, big_n);
    // >> 5 -> 50
}

// 8.2 loop

/*
Rust предоставляет ключевое слово loop для обозначения бесконечного цикла.
Оператор break используется, чтобы выйти из цикла в любое время, а оператор continue используется,
    чтобы пропустить оставшуюся часть цикла и начать новую итерацию.
*/

fn loop_() {
    let mut count = 0u32;

    println!("Давайте считать до бесконечности!");

    loop {
        count += 1;

        if count == 3 {
            println!("Три");
            // Пропустить оставшуюся часть итерации
            continue;
        }

        println!("{}", count);

        if count == 5 {
            println!("Всё, достаточно");
            // Выйти из цикла
            break;
        }
    }
}

// 8.2.1 Вложенность и метки
/*
Можно прерывать выполнение внешних циклов с помощью break или continue,
    когда речь заходит о вложенных циклах. Для этого циклы должны быть обозначены метками вроде 'label,
    а метки должны быть переданы операторам break или continue.
*/
#[allow(unreachable_code)]
#[allow(unused_labels)]

fn nesting_and_labels() {
    // Установка метки на внешний цикл
    'outer: loop {
        println!("Вошли во внешний цикл");
        // Установка метки на внутрений цикл
        'inner: loop {
            println!("Вошли во внутрений цикл");
            // Завершения внешнего цикла внутри внутреного цикла. С помощью метки
            break 'outer;
        }
        println!("Эта точка не будет достигнута");
    }
    println!("Вышли из внешнего цикла");
}

// 8.2.2 Возврат из циклов
/*
Одним из видов использования цикла loop является повторение операции, пока она не будет выполнена.
Если операция возвращает значение, вам может потребоваться передать его в другую часть кода:
    поместите его после break, и оно будет возвращено выражением loop.
*/

fn return_loop() {
    let mut counter = 0;

    let resul = loop {
        counter += 1;

        if counter == 10 {
            // Возрат значения из цикла
            break counter * 2;
        }
    };
    println!("Результат: {} и счётчик: {}", resul, counter);
    // >> Результат: 20 и счётчик: 10
    assert_eq!(resul, 20);
}

// 8.3 while
// Ключевое слово while используется для создания цикла, который будет выполняться, пока условие истинно.

fn while_() {
    let mut n = 1;

    // Цикл while будет работать, пока `n` меньше 101
    while n < 101 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }
        // Увеличиваем значение счётчика
        n += 1;
    }
}

// 8.4 Цикл for и range
/*
Конструкция for in может быть использована для итерации по итераторам (Iterator).
Один из самых простых способов создать итератор это использовать диапазон значений a..b.
Это вернёт нам значения от a (включительно) до b (исключительно) за один шаг.
*/

fn for_() {
    /*
    1.. 101 - `n` будет принимать значения: 1, 2, ..., 100 с каждой итерации
    Также, может быть использован диапазон a..=b, включающий оба конца. Код выше может быть записан следующим образом:
    1..=100  - n` будет принимать значения: 1, 2, ..., 100 с каждой итерации
    */

    for n in 1..101 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }
    }
    /*
    Конструкция for in может взаимодействовать с итератором разными способами.
    Как обсуждается далее про типаж Iterator, цикл for применяет к предоставленной коллекции метод into_iter,
        чтобы преобразовать её в итератор.
    Однако, это не единственный способ преобразования коллекции в итератор.

    Каждый из методов into_iter, iter и iter_mut преобразует коллекцию в итератор по своему,
        предоставляя разные отображения содержащихся данных.
    */

    let names = vec!["Bob", "Frank", "Ferris"];

    /*
    iter -  эта функция заимствует каждый элемент коллекции (на каждой итерации.)
        Благодаря этому, он оставляет коллекцию нетронутой и доступной для использования после цикла.s
    */
    for name in names.iter() {
        match name {
            // Получение ссылки от строки "Ferris"
            &"Ferris" => println!("Программисты Rust вокруг нас!"),
            _ => println!("Привет {}", name),
        }
    }

    /*
    into_iter - эта функция потребляет коллекцию так что на каждой итерации предоставляются данные.
        Коллекция больше не доступна для использования так как владение ею перешло в эту функцию.
    */

    for name in names.into_iter() {
        match name {
            // Тут не требуется ссылка так как into_iter получило владение над колеекцией `names`
            "Ferris" => println!("Программисты Rust вокруг нас!"),
            _ => println!("Привет {}", name),
        }
    }
    /*
    iter_mut - эта функция делает изменяемое заимствование каждого элемента коллекции, позволяя изменять коллекцию на месте.
    */
    let mut names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter_mut() {
        *name = match name {
            // Тут используется изменяемая ссылка
            &mut "Ferris" => "Программисты Rust вокруг нас!",
            _ => "Привет",
        }
    }
    println!("Изменёные имена {:?}", names);
    // >> Изменёные имена ["Привет", "Привет", "Программисты Rust вокруг нас!"]
}

pub fn run8() {
    if_else();
    loop_();
    nesting_and_labels();
    return_loop();
    while_();
    for_();
}
