// Атрибут, который убирает предупреждения компилятора о неиспользуемом коде
#![allow(dead_code)]
#![allow(unused_variables)]

// 8 Управление потоком
// Неотъемлемой частью любого языка программирования являются управляющие конструкции: if / else , for и другие.

// 8.1 if/else

/*
Ветвление с помощью if-else похоже на аналоги в других языка программирования.
В отличие от многих из них, логическое условие не должно быть заключено в круглые скобки,
    а после каждого условия должен следовать блок.
Условные операторы if-else являются выражениями, и все ветки должны возвращать значения одного и того же типа.
*/

fn if_else() {
    let n = 5;
    if n < 0 {
        println!("{} - Отрицательное число", n);
    } else if n > 0 {
        println!("{} - Положительное число", n);
    } else {
        println!("{} - нуль", n);
    }

    let big_n = if n < 10 && n > -10 {
        println!(", малое по модулю число, умножим его в десять раз");
        // Это выражение вернёт `i32`.
        10 * n
    } else {
        println!(", большое по модулю число, уменьшим его в вдвое");
        // И это выражение вернёт `i32`.
        n / 2
    };
    // Не забудьте добавить тут точку с запятой! Все операторы `let` требуют её..

    println!("{} -> {:?}", n, big_n);
    // >> 5 -> 50
}

// 8.2 loop

/*
Rust предоставляет ключевое слово loop для обозначения бесконечного цикла.
Оператор break используется, чтобы выйти из цикла в любое время, а оператор continue используется,
    чтобы пропустить оставшуюся часть цикла и начать новую итерацию.
*/

fn loop_() {
    let mut count = 0u32;

    println!("Давайте считать до бесконечности!");

    loop {
        count += 1;

        if count == 3 {
            println!("Три");
            // Пропустить оставшуюся часть итерации
            continue;
        }

        println!("{}", count);

        if count == 5 {
            println!("Всё, достаточно");
            // Выйти из цикла
            break;
        }
    }
}

// 8.2.1 Вложенность и метки
/*
Можно прерывать выполнение внешних циклов с помощью break или continue,
    когда речь заходит о вложенных циклах. Для этого циклы должны быть обозначены метками вроде 'label,
    а метки должны быть переданы операторам break или continue.
*/
#[allow(unreachable_code)]
#[allow(unused_labels)]

fn nesting_and_labels() {
    // Установка метки на внешний цикл
    'outer: loop {
        println!("Вошли во внешний цикл");
        // Установка метки на внутрений цикл
        'inner: loop {
            println!("Вошли во внутрений цикл");
            // Завершения внешнего цикла внутри внутреного цикла. С помощью метки
            break 'outer;
        }
        println!("Эта точка не будет достигнута");
    }
    println!("Вышли из внешнего цикла");
}

// 8.2.2 Возврат из циклов
/*
Одним из видов использования цикла loop является повторение операции, пока она не будет выполнена.
Если операция возвращает значение, вам может потребоваться передать его в другую часть кода:
    поместите его после break, и оно будет возвращено выражением loop.
*/

fn return_loop() {
    let mut counter = 0;

    let resul = loop {
        counter += 1;

        if counter == 10 {
            // Возрат значения из цикла
            break counter * 2;
        }
    };
    println!("Результат: {} и счётчик: {}", resul, counter);
    // >> Результат: 20 и счётчик: 10
    assert_eq!(resul, 20);
}

// 8.3 while
// Ключевое слово while используется для создания цикла, который будет выполняться, пока условие истинно.

fn while_() {
    let mut n = 1;

    // Цикл while будет работать, пока `n` меньше 101
    while n < 101 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }
        // Увеличиваем значение счётчика
        n += 1;
    }
}

// 8.4 Цикл for и range
/*
Конструкция for in может быть использована для итерации по итераторам (Iterator).
Один из самых простых способов создать итератор это использовать диапазон значений a..b.
Это вернёт нам значения от a (включительно) до b (исключительно) за один шаг.
*/

fn for_() {
    /*
    1.. 101 - `n` будет принимать значения: 1, 2, ..., 100 с каждой итерации
    Также, может быть использован диапазон a..=b, включающий оба конца. Код выше может быть записан следующим образом:
    1..=100  - n` будет принимать значения: 1, 2, ..., 100 с каждой итерации
    */

    for n in 1..101 {
        if n % 15 == 0 {
            println!("fizzbuzz");
        } else if n % 3 == 0 {
            println!("fizz");
        } else if n % 5 == 0 {
            println!("buzz");
        } else {
            println!("{}", n);
        }
    }
    /*
    Конструкция for in может взаимодействовать с итератором разными способами.
    Как обсуждается далее про типаж Iterator, цикл for применяет к предоставленной коллекции метод into_iter,
        чтобы преобразовать её в итератор.
    Однако, это не единственный способ преобразования коллекции в итератор.

    Каждый из методов into_iter, iter и iter_mut преобразует коллекцию в итератор по своему,
        предоставляя разные отображения содержащихся данных.
    */

    let names = vec!["Bob", "Frank", "Ferris"];

    /*
    iter -  эта функция заимствует каждый элемент коллекции (на каждой итерации.)
        Благодаря этому, он оставляет коллекцию нетронутой и доступной для использования после цикла.s
    */
    for name in names.iter() {
        match name {
            // Получение ссылки от строки "Ferris"
            &"Ferris" => println!("Программисты Rust вокруг нас!"),
            _ => println!("Привет {}", name),
        }
    }

    /*
    into_iter - эта функция потребляет коллекцию так что на каждой итерации предоставляются данные.
        Коллекция больше не доступна для использования так как владение ею перешло в эту функцию.
    */

    for name in names.into_iter() {
        match name {
            // Тут не требуется ссылка так как into_iter получило владение над колеекцией `names`
            "Ferris" => println!("Программисты Rust вокруг нас!"),
            _ => println!("Привет {}", name),
        }
    }
    /*
    iter_mut - эта функция делает изменяемое заимствование каждого элемента коллекции, позволяя изменять коллекцию на месте.
    */
    let mut names = vec!["Bob", "Frank", "Ferris"];

    for name in names.iter_mut() {
        *name = match name {
            // Тут используется изменяемая ссылка
            &mut "Ferris" => "Программисты Rust вокруг нас!",
            _ => "Привет",
        }
    }
    println!("Изменёные имена {:?}", names);
    // >> Изменёные имена ["Привет", "Привет", "Программисты Rust вокруг нас!"]
}

// 8.5 March

/*
Rust обеспечивает сопоставление с образцом с помощью ключевого слова match ,
    которое можно использовать похожим образом, как switch в языке C.
Срабатывает первая подходящая ветка, и все возможные значения должны быть перечислены.
*/

fn _mathc() {
    let number = 13;

    println!("Расскажи мне о {}", number);

    match number {
        // Одно значение
        1 => println!("Один!"),
        // Много значений
        2 | 3 | 5 | 7 | 11 => println!("Это простое число"),
        // Выбирает диапазон, включающий границы
        13..=19 => println!("от 13 до 19"),
        // Обрабатывает оставшиеся случаи
        _ => println!("Ничего особенного"),
    }

    let boolean = true;
    // Match ещё и выражение
    let binary = match boolean {
        false => 0,
        true => 1,
    };
    println!("{} -> {}", boolean, binary);
    // >> true -> 1
}

// 8.5.1 Деструктуризация
/*
Блок match может деструктурировать элементы в различных формах.

    Перечисления
    Указатели
    Структуры
    Кортежи

*/
// 8.5.1.1 Кортежи

fn match_tuple() {
    let triple = (0, -2, 3);

    println!("Расскажи мне о {:?}", triple);
    // >> Расскажи мне о (0, -2, 3)
    // Для деструктурирования можно использовать match
    match triple {
        // Деструктурируем второй и третий элементы
        (0, y, z) => println!("Первый равен `0`, `y` равен {:?}, `z` равен {:?}", y, z),
        // `..` можно использовать, чтобы игнорировать оставшуюся часть кортежа
        (1, ..) => println!("Первый равен `1`, остальное не важно"),
        (.., 2) => println!("Последний равен `2`, остальное не важно"),
        (3, .., 4) => println!("Первый равен `3`, последний равен `4`, остальное не важно"),
        // `_` означает, значение не будет присвоено переменной
        _ => println!("Не важно чему они равны"),
    }
}

// 8.5.1.2 Перечисления
enum Color {
    Red,
    Blue,
    Green,
    RGB(u32, u32, u32),
    HSV(u32, u32, u32),
    HSL(u32, u32, u32),
    CMY(u32, u32, u32),
    CMYK(u32, u32, u32, u32),
}

fn match_enum() {
    let color = Color::Blue;
    // let color = Color::RGB(122, 17, 40);
    // let color = Color::CMYK(122, 17, 12, 111);

    println!("Какой это цвет?");
    // >> Какой это цвет?

    // `enum` может быть деструктурирован с помощью `match`.
    match color {
        Color::Red => println!("Красный цвет!"),
        Color::Blue => println!("Синий цвет!"),
        Color::Green => println!("Зелёный цвет!"),
        Color::RGB(r, g, b) => {
            println!("Красный: {}, Зелёный: {}, Синий {}", r, g, b)
        }
        Color::HSV(h, s, v) => {
            println!("Тон: {}, Насыщеность: {}, Значение: {}", h, s, v)
        }
        Color::HSL(h, s, l) => {
            println!("Тон: {}, Насыщеность: {}, Светолота: {}", h, s, l)
        }
        Color::CMY(c, m, y) => {
            println!("Голубой: {}, Пурпурный: {}, Жёлтый: {}", c, m, y)
        }
        Color::CMYK(c, m, y, k) => {
            println!(
                "Голубой: {}, Пурпурный: {}, Жёлтый: {}, key(чёрный) {}!",
                c, m, y, k
            )
        }
    }
}

// 8.5.1.3 Указатели и ссылки
/*
Для указателей нужно отметить разницу между деструктуризацией и разыменованием,
    так как это разные понятия, которые используются по разному начиная с языков вроде C/C++.

    Разыменование использует *
    Деструктуризация использует &, ref и ref mut

*/

fn match_link_and_signposts() {
    // Присваиваем ссылку на тип `i32`.
    // Символ `&` означает, что присваивается ссылка.
    let reference = &4;

    // Деструктуризация
    match reference {
        /*
        Если `reference` - это шаблон, который сопоставляется с `&val`, то это приведёт к сравнению:
        `&i32` = `&val`
        Мы видим, что если отбросить сопоставляемые `&`, то переменной `val` должно быть присвоено `i32`.
        */
        &val => println!("Получаем значене через деструктуризацию: {:?}", val),
    }
    // >> Получаем значене через деструктуризацию: 4

    // Разыменование
    // Чтобы избежать символа `&`, нужно разыменовывать ссылку до сопоставления.
    // Разыменование `*`
    match *reference {
        val => println!("Получаем значение через разменованвание: {}", val),
    }
    // >> Получаем значение через разменованвание: 4

    /*
    Что если у нас нет ссылки? `reference` была с `&`,
        потому что правая часть была ссылкой. Но это не ссылка,
        потому что правая часть ею не является.
    */
    let _not_a_reference = 3;

    /*
    Rust предоставляет ключевое слово `ref` именно для этой цели.
    Оно изменяет присваивание так, что создаётся ссылка для элемента.
    Теперь ссылка присвоена.
    */
    let ref _is_a_reference = 3;

    // Соответственно, для определения двух значений без ссылок,
    // ссылки можно назначить с помощью `ref` и `ref mut`.
    let value = 5;
    let mut mut_value = 6;

    // Используйте ключевое слово `ref` для создания ссылки.
    match value {
        ref r => println!("Получим ссылку на значение: {:?}", r),
    }
    // >> Получим ссылку на значение: 5

    // Используйте `ref mut` аналогичным образом.
    match mut_value {
        ref mut m => {
            // Получаем ссылку. Её нужно разыменовать, прежде чем мы сможем что-то добавить.
            *m += 10;
            println!("Мы добавили 10. `mut_value`: {:?}", m);
        }
    }
    // Мы добавили 10. `mut_value`: 16
}

// 8.5.1.4 Структуры

fn match_struct() {
    struct Foo {
        x: (u32, u32),
        y: u32,
    }

    // деструктуризация члена структуры
    let foo = Foo { x: (1, 2), y: 3 };
    let Foo { x: (a, b), y } = foo;

    println!("a={}, b={}, y={}", a, b, y);
    // >> a=1, b=2, y=3

    // Вы можете деструктурировать структуру и переименовывать переменные,
    // порядок при этом не важен
    let Foo { y: i, x: j } = foo;
    println!("i={:?}, j={:?}", i, j);
    // >> i=3, j=(1, 2)

    // а так же можно проигнорировать часть переменных:
    let Foo { y, .. } = foo;
    println!("y={}", y);
    // >> y=3

    // следующий код выдаст ошибку: в шаблоне нет упоминания поля `x`
    // let Foo{y} = foo;
}

// 8.5.2 Ограничители шаблонов
/*
Внутри конструкции match можно добавить ограничитель шаблонов для фильтрации возможных вариантов.
*/

fn match_limited() {
    let pair = (2, -2);
    println!("Pасскажи мне о {:?}", pair);
    // >> Pасскажи мне о (2, -2)

    match pair {
        // Данное ^ `условие if` является ограничителем шаблонов
        (x, y) if x == y => println!("Близнецы"),
        (x, y) if x + y == 0 => println!("Антиматерия, бабах!"),
        (x, _) if x % 2 == 1 => println!("Первое число нечётное"),
        _ => println!("Нет корреляции..."),
    }
}
// 8.5.3 Связывание

/*
Косвенный доступ к переменной делает невозможным ветвление и использование переменной без повторной привязки.
match предоставляет символ @ для привязки значения к имени:
*/

// Функция `age`, возвращающая `u32`.
fn age() -> u32 {
    15
}

// Вы также можете использовать привязку для "деструктурирования" вариантов enum, таких как Option:
fn some_number() -> Option<u32> {
    Some(42)
}

fn match_tiung() {
    println!("Скажи мне свой возраст");

    match age() {
        0 => println!("Я ещё не отпраздновал свой первый день рождения"),
        /*
        Можно было бы использовать только 1 ... 12 в `match`,
            но какого возраста тогда был бы ребёнок? Вместо этого мы
            привязываем `n` к последовательности 1 .. 12.
            Теперь мы можем сообщить возраст.
        */
        n @ 1..=12 => println!("Я ребёнок. Мне {:?}", n),
        n @ 13..=19 => println!("Я подросток. Мне {:?}", n),
        // Ничего не привязываем
        n => println!("Я взрослый. Мне {:?}", n),
    }

    match some_number() {
        // Вариант `Some`, выбираем, если его значение, привязанное к `n`, равно 42.
        Some(n @ 42) => println!("Ответ: {}!", n),
        // При других числах.
        Some(n) => println!("Не интересно... {}", n),
        // Для всего остального (вариант `None`).
        _ => (),
    }
}

// 8.6 if let
// В некоторых случаях использование match выглядит неуклюже. Например:

fn if_let() {
    let optional = Some(7);

    match optional {
        Some(i) => {
            println!("Это очень большая строка и {:?}", i)
            // ^ Нужно 2 отступа только для того, чтобы извлечь `i`
        }
        _ => {} // ^ Обязателен, так как `match` исчерпывающий. Не выглядит ли это как зря потраченное пространство?
    }
    /*
    if let намного компактнее и выразительнее для данного случая и,
        кроме того, позволяет рассмотреть различные варианты ошибок.
    */
    let number = Some(7);
    let letter: Option<i32> = None;
    let emoticon: Option<i32> = None;

    /*
    Конструкция `if let` читает, как:
    `"Если `let` деструктуризирует `number` в `Some(i)`, выполнить блок (`{}`).
    */
    if let Some(i) = number {
        println!("Соответствует {:?}!", i);
        // >> Соответствует 7!
    }

    // Если нужно указать, что делать, в случае ошибки, можно добавить else:
    if let Some(i) = letter {
        print!("Соответствует {:?}", i);
    } else {
        // Ошибка деструктуризации. Переходим к обработке ошибки.
        println!("Не соответветствует числу. Давайте попробуем строку!");
        // >> Не соответветствует числу. Давайте попробуем строку!
    }

    // Добавляем ещё одну ситуацию несоответствия образцу.
    let i_like_letters = false;

    if let Some(i) = emoticon {
        println!("Соответствует {:?}!", i);
    // Оцените условие `else if`, чтобы увидеть, должна ли быть альтернативная ветка отказа:
    } else if i_like_letters {
        println!("Не соответствует числу. Давайте попробуем строку!");
    } else {
        // Рассматриваем ложное условие. Эта ветвь по умолчанию:
        println!("Мне не нравиться сравнивать строки. Давайте возьмём смайлик :)!");
    }

    // Точно так же, if let может быть использован для сравнения любого значения перечисления:

    // Наш пример перечисления
    #[derive(Debug)]
    enum Foo {
        Bar,
        Baz,
        Qux(u32),
    }

    // Создание переменных примера
    let a = Foo::Bar;
    let b = Foo::Baz;
    let c = Foo::Qux(100);

    // Переменная `a` соответствует `Foo::Bar`
    if let Foo::Bar = a {
        println!("a = Foo::Bar");
        // >> a = Foo::Bar
    }

    // Переменная `b` не соответствует `Foo::Bar`. Поэтому ничего не выведется на экран
    if let Foo::Bar = b {
        println!("b = Foo::Bar, b = {:?}", b);
    }

    /*
    Переменная `c` соответствует `Foo::Qux`, которая имеет значение
        аналогичное `Some()` как в предыдущем примере:
    */
    if let Foo::Qux(value) = c {
        println!("c = {}", value);
        //  c = 100
    }

    // С `if let` также работает и привязка
    if let Foo::Qux(value @ 100) = c {
        println!("c = 100, {}", value);
        // c = 100, 100
    }

    /*
    Другое преимущество if let в том, что он позволяет сопоставлять нам не параметризованные варианты перечисления.
    Это возможно даже если для перечисления не реализован и не выведен типаж PartialEq.
    В некоторых случаях, if Foo::Bar == a не скомпилируется, потому что экземпляры перечисления не могут быть равны.
    Однако, с if let всё будет работать.
    */

    // Для это перечисление намеренно не добавлен #[derive(PartialEq)],
    // и мы не реализовывали для него PartialEq. Вот почему сравнение Foo::Bar == a терпит неудачу.

    let a = Foo::Bar;

    // Переменная соответствует Foo::Bar
    // if Foo::Bar == a {
    //     // ^-- это вызовет ошибку компиляции. Используйте `if let` вместо этого.
    //     println!("a is foobar");
    // }
}

// 8.7 while let
/*
Так же, как иif let, while let может сделать неудобный match более терпимым.
*/

fn while_let() {
    let mut optional = Some(0);

    loop {
        match optional {
            // Если `optional` деструктурируется, выполним следующий блок.
            Some(i) => {
                if i > 9 {
                    println!("Больше 9, уходим отсюда!");
                    optional = None;
                } else {
                    println!("`i` равен `{:?}`. Попробуем ещё раз.", i);
                    optional = Some(i + 1);
                }
                // ^ Требует 3 уровня вложенности!
            }
            // Выходим из цикла в случае ошибки деструктуризации:
            _ => {
                break;
            } // ^ Зачем это нужно? Должен быть способ сделать это лучше!
        }
    }

    // Возвращем Some к начальному значению
    optional = Some(0);

    /*
    Это можно прочитать так: "Пока `let` деструктурирует `optional` в
    `Some(i)`, выполняем блок (`{}`). В противном случае `break`.
    */
    while let Some(i) = optional {
        if i > 9 {
            println!("Больше 9, уходим отсюда!");
            optional = None;
        } else {
            println!("`i` равен `{:?}`. Попробуем ещё раз.", i);
            optional = Some(i + 1)
        }
        // ^ Меньше смещаемся вправо, к тому же нет необходимости обрабатывать ошибки.
    }
    // ^ К `if let` можно добавить дополнительный блок `else`/`else if`. Для `while let` подобного нет.
}

pub fn run8() {
    if_else();
    loop_();
    nesting_and_labels();
    return_loop();
    while_();
    for_();
    _mathc();
    match_tuple();
    match_enum();
    match_link_and_signposts();
    match_struct();
    match_limited();
    match_tiung();
    if_let();
    while_let();
}
